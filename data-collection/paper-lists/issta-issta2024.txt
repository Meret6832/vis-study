a large-scale empirical study on improving the fairness of image classification models
a large-scale evaluation for log parsing techniques: how far are we?
ai coders are among us: rethinking programming language grammar towards efficient code generation
an empirical examination of fuzzer mutator performance
an empirical study of static analysis tools for secure code review
an empirical study on kubernetes operator bugs
an in-depth study of runtime verification overheads during software testing
api misuse detection via probabilistic graphical model
arfa: an agile regime-based floating-point optimization approach for rounding errors
asfuzzer: differential testing of assemblers with error-driven grammar inference
atlas: automating cross-language fuzzing on android closed-source libraries
autocoderover: autonomous program improvement
automated data binding vulnerability detection for java web frameworks via nested property graph
automated deep learning optimization via dsl-based source code transformation
automated program repair via conversation: fixing 162 out of 337 bugs for $0.42 each using chatgpt
automating zero-shot patch porting for hard forks
benchmarking automated program repair: an extensive study on both real-world and artificial bugs
better not together: staged solving for context-free language reachability
beyond pairwise testing: advancing 3-wise combinatorial interaction testing for highly configurable systems
brafar: bidirectional refactoring, alignment, fault localization, and repair for programming assignments
bridge and hint: extending pre-trained language models for long-range code
bugs in pods: understanding bugs in container runtime systems
c2d2: extracting critical changes for real-world bugs with dependency-sensitive delta debugging
calico: automated knowledge calibration and diagnosis for elevating ai mastery in code tasks
call graph soundness in android static analysis
cebin: a cost-effective framework for large-scale binary code similarity detection
certified continual learning for neural network regression
characterizing and detecting program representation faults of static analysis frameworks
clap: learning transferable binary code representations with natural language supervision
coderujb: an executable and unified java benchmark for practical programming scenarios
coedpilot: recommending code edits with learned prior edit relevance, project-wise awareness, and interactive nature
commit artifact preserving build prediction
cootest: an automated testing approach for v2x communication systems
cosec: on-the-fly security hardening of code llms via supervised co-decoding
cref: an llm-based conversational software repair framework for programming tutors
dance of the ads: orchestrating failures through historically-informed scenario fuzzing
dappfl: just-in-time fault localization for decentralized applications in web3
datactive: data fault localization for object detection systems
dbstorm: generating various effective workloads for testing isolation levels
ddgf: dynamic directed greybox fuzzing with path profiling
decomposition of deep neural networks into modules via mutation analysis
define-use guided path exploration for better forced execution
defort: automatic detection and analysis of price manipulation attacks in defi applications
delink: source file information recovery in binaries
detecting build dependency errors in incremental builds
diavio: llm-empowered diagnosis of safety violations in ads simulation testing
distance-aware test input selection for deep neural networks
distillseq: a framework for safety alignment testing in large language models using knowledge distillation
domain adaptation for code model-based unit test case generation
efficient dnn-powered software with fair sparse models
empirical study of move smart contract security: introducing movescan for enhanced analysis
enhancing multi-agent system testing with diversity-guided exploration and adaptive critical state exploitation
enhancing robustness of code authorship attribution through expert feature knowledge
enhancing ros system fuzzing through callback tracing
equivalent mutants in the wild: identifying and efficiently suppressing equivalent mutants for java programs
evaluating deep neural networks in deployment: a comparative study (replicability study)
evaluating the effectiveness of decompilers
exploration-driven reinforcement learning for avionic system fault detection (experience paper)
face it yourselves: an llm-based two-stage strategy to localize configuration errors via logs
fastlog: an end-to-end method to efficiently generate and insert logging statements
fdi: attack neural code generation systems through user feedback channel
feedback-directed partial execution
feedback-driven automated whole bug report reproduction for android apps
finding cuts in static analysis graphs to debloat software
foliage: nourishing evolving software by characterizing and clustering field bugs
following the “thread”: toward finding manipulatable bottlenecks in blockchain clients
fortifypatch: towards tamper-resistant live patching in linux-based hypervisor
fries: fuzzing rust library interactions via efficient ecosystem-guided target generation
ft2ra: a fine-tuning-inspired approach to retrieval-augmented code completion
funredisp: reordering function dispatch in smart contract to reduce invocation gas fees
fuzzing javascript interpreters with coverage-guided reinforcement learning for llm-based mutation
fuzzing mlir compiler infrastructure via operation dependency analysis
graph neural networks for vulnerability detection: a counterfactual explanation
guardian: a runtime framework for llm-based ui exploration
how effective are they? exploring large language model based fuzz driver generation
identifying smart contract security issues in code snippets from stack overflow
inconsistencies in tex-produced documents
interoperability in deep learning: a user survey and failure analysis of onnx model converters
interpretability based neural network repair
interprocedural path complexity analysis
isolation-based debugging for neural networks
large language models can connect the dots: exploring model optimization bugs with domain knowledge-aware prompts
large language models for equivalent mutant detection: how far are we?
learning to check ltl satisfiability and to generate traces via differentiable trace checking
lent-sse: leveraging executed and near transactions for speculative symbolic execution of smart contracts
llm4fin: fully automating llm-powered test case generation for fintech software acceptance testing
logos: log guided fuzzing for protocol implementations
lpr: large language models-aided program reduction
ma11y: a mutation framework for web accessibility testing
maltracker: a fine-grained npm malware tracker copiloted by llm-enhanced dataset
microres: versatile resilience profiling in microservices via degradation dissemination indexing
midas: mining profitable exploits in on-chain smart contracts via feedback-driven fuzzing and differential analysis
model-less is the best model: generating pure code implementations to replace on-device dl models
multi-modal learning for webassembly reverse engineering
nativesummary: summarizing native binary code for inter-language static analysis of android apps
neufair: neural network fairness repair with dropout
neurosymbolic repair of test flakiness
one size does not fit all: multi-granularity patch generation for better automated program repair
one-to-one or one-to-many? suggesting extract class refactoring opportunities with intra-class dependency hypergraph neural network
oracle-guided program selection from large language models
patchfinder: a two-phase approach to security patch tracing for disclosed vulnerabilities in open-source software
policy testing with mdpfuzz (replicability study)
practitioners’ expectations on automated test generation
precise compositional buffer overflow detection via heap disjointness
preserving reactiveness: understanding and improving the debugging practice of blocking-call bugs
prospector: boosting directed greybox fuzzing for large-scale target sets with iterative prioritization
reproducing timing-dependent gui flaky tests in android apps via a single event delay
revisiting test-case prioritization on long-running test suites
scalable, sound, and accurate jump table analysis
scale: constructing structured natural language comment trees for software vulnerability detection
see the forest, not trees: unveiling and escaping the pitfalls of error-triggering inputs in neural network testing
segment-based test case prioritization: a multi-objective approach
selfpico: self-guided partial code execution with llms
semantic constraint inference for web form test generation
silent taint-style vulnerability fixes identification
sleuth: a switchable dual-mode fuzzer to investigate bug impacts following a single poc
sqless: dialect-agnostic sql query simplification
synthesis of sound and precise storage cost bounds via unsound resource analysis and max-smt
synthesis-based enhancement for gui test case migration
synthesizing boxes preconditions for deep neural networks
tacoma: enhanced browser fuzzing with fine-grained semantic alignment
teda: a testing framework for data usage auditing in deep learning model development
test selection for deep neural networks using meta-models with uncertainty metrics
testing graph database systems with graph-state persistence oracle
testing gremlin-based graph database systems via query disassembling
thinkrepair: self-directed automated program repair
total recall? how good are static call graphs really?
toward the automated localization of buggy mobile app uis from bug descriptions
towards automatic oracle prediction for ar testing: assessing virtual object placement quality under real-world scenes
towards more complete constraints for deep learning library testing via complementary set guided refinement
towards understanding the bugs in solidity compiler
traceback: a fault localization technique for molecular programs
uncovering and mitigating the impact of code obfuscation on dataset annotation with antivirus engines
understanding misconfigurations in ros: an empirical study and current approaches
unimocg: modular call-graph algorithms for consistent handling of language features
unitsyn: a large-scale dataset capable of enhancing the prowess of large language models for program testing
upbeat: test input checks of q# quantum libraries
viohawk: detecting traffic violations of autonomous driving systems through criticality-guided simulation testing
vrdsynth: synthesizing programs for multilingual visually rich document information extraction
wapplique: testing webassembly runtime via execution context-aware bytecode mutation
wasmaker: differential testing of webassembly runtimes via semantic-aware binary generation
when to stop? towards efficient code generation in llms with excess token prevention
your “notice” is missing: detecting and fixing violations of modification terms in open source licenses during forking